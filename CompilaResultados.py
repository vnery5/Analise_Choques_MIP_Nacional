"""
Sectorial analysis based on estimated matrices by EstimaMIP_Nacional (every version).

Important: sheet formatting has to be the SAME as those generated by EstimaMIP (including "Difference" line at the end)

Based on: VALE, V. A.; PEROBELLI, F. S.. Análise de Insumo-Produto: teoria e aplicações no R. NEDUR/LATES, 2020.

Authors: João Maria de Oliveira and Vinícius de Almeida Nery Ferreira (Ipea-DF).

E-mails: joao.oliveira@ipea.gov.br and vinicius.nery@ipea.gov.br (or vnery5@gmail.com).
"""

## Importing necessary packages
import numpy as np
import pandas as pd
import datetime
import SupportFunctions as Support

## Only run if it's the main file (don't run on import)
if __name__ == '__main__':
    nYear0 = 2010
    nYear1 = 2019 + 1
    for nYear in range(nYear0, nYear1):
        print(nYear)
        ## Matrix dimension
        # 1: 12 sectors
        # 2: 20 sectors
        # 3: 51 sectors
        # 4: 68 sectors
        # 9: more than 68 sectors ("68+") - Currently, programmed to read 72 sectors (disaggregation of education)
        # 0: other (specify number of sectors below)
        nDimension = 4

        ## Use MIPs estimated under Guilhoto (2010) or Alves-Passoni, Freitas (APF) (2020)?
        # If decided to use APF's matrices, remember to specify nDimension = 0 and nSectorsFile = 67 on line 60
        bGuilhoto = True  # True or False

        ## Whether to create and save figures and write spreadsheet
        bSaveFig = False  # True or False
        bWriteExcel = False  # True or False

        ## Highlight one sector? If so, which index and color?
        bHighlightSectorFigs = True  # True or False
        nIndexHighlightSectorsFigs = 11  # 3, 11 or 37: Electricity & Gas (base 0 index)
        sHighlightColor = "red"

        ## Closed model methodology: use Guilhoto's (True) or Vale, Perobelli's (False)?
        bClosedGuilhoto = False  # True or False
        # If bClosedGuilhoto, update added values components in output MIP?
        bUpdateMIPClosedGuilhoto = True

        ## Column and row numbers (base 0) (we don't need to worry about n = 51 because Guilhoto isn't possible)
        # Final Demand
        nColISFLSFConsumption = 2
        nColFamilyConsumption = 3
        # Added Value
        nRowRemunerations = 1
        nRowRM = 8
        nRowEOB = 9
        # Energy
        nRowEnergy = 37 if nDimension == 4 else 11  # Electricity & Gas (base 0 index)

        ### ============================================================================================

        ### Defining file paths and names
        if nDimension == 0:
            nSectorsFile = 25  # How many sectors?
            invalidSectorNumber = ""
        elif nDimension == 9:
            nSectorsFile = "68+"
            invalidSectorNumber = ""
        else:
            ## Dimensions -> sectors list
            listDimensions = [12, 20, 51, 68]
            try:
                nSectorsFile = listDimensions[nDimension - 1]
                invalidSectorNumber = ""
            except IndexError:
                nSectorsFile = listDimensions[3]
                invalidSectorNumber = "Couldn't find desired dimension. Running for 68 sectors."
                nDimension = 4

        ## Estimated MIPs files
        # Sheet formatting has to be the SAME as those generated by EstimaMIP (including a "difference" line at the end)
        sPathMIP = "./Input/MIPs Estimadas/"
        sAPF = "" if bGuilhoto else "_Patieene"
        sFileNameMIP = f"MIP_{nYear}_{nSectorsFile}{sAPF}.xlsx"

        # Joining path and file name
        sFileMIP = sPathMIP + sFileNameMIP

        # Sheet name
        sSheetNameMIP = "MIP"

        ## Figure Indicator
        bSaveFigIndicator = " (WITH figures)..." if bSaveFig else " (WITHOUT figures)..."

        ### ============================================================================================

        ### Print start
        sTimeBegin = datetime.datetime.now()
        print("======================= COMPILATION OF INPUT OUTPUT INDICATORS - VERSION 1 =======================")
        print(f"Starting for year = {nYear} and dimension = {nDimension}{bSaveFigIndicator} ({sTimeBegin})")
        print(invalidSectorNumber)

        ## Read necessary matrices and get number of sectors and sector's names
        dfMIP, nSectors, vSectors, mZ, mY, mX, mC, mV, mR, mE, mSP, vAVNames, mAddedValue, vFDNames, mFinalDemand = \
            Support.read_estimated_mip(sFileMIP, sSheetName=sSheetNameMIP)

        # Getting payment sector of the final demand components
        mSP_FD = dfMIP.values[nSectors + 1:nSectors + 6, nSectors + 1:-2]

        ### ============================================================================================
        ### Technical Coefficients (mA and mB) (Closed, Open and Supply)
        ### ============================================================================================

        ### Open Model
        ## Technical Coefficients and Leontief's Matrix
        """
        mA (Technical Coefficients) tells us the monetary value of inputs from sector i
        that sector j directly needs to output/produce 1 unit,
        On the other hand, mB tells us, given a increase of 1 monetary value in the demand for products of sector j,
        how much should the production of each sector increase
        """
        mA, mB = Support.leontief_open(mZ, mX, nSectors)

        ### Closed Model
        """
        The open model captures only the direct and indirect impacts connected to intersectorial technical relations
        of buying and selling products, leaving out the effects induced by changes in income and consumption.
        In order to capture these phenomena, the model must be "closed" in relation to the families, 
        turning household consumption into an endogenous variable alongside labor remunerations
        """
        ## Calculating Coefficients
        ## Methodology proposed by Vale, Perobelli, 2021
        ## n = 51 sectors doesn't have the differentiation between EOB and RM (required for Guilhoto's methodology)
        if not bClosedGuilhoto or nDimension == 3:
            ## Indicator for differentiation when saving spreadsheet
            sClosedGuilhotoIndicator = "_Closed_Perobelli"
            print("Closed model: Vale and Perobelli")

            # Consumption: what families (not including ISFLSF) consume of each sector in respect to total income
            # (only including remunerations or, in other words, excluding EOB and RM)
            hC = mC / np.sum(mR)

            # Remunerations (transposed): percentage of each sector's production that becomes income
            hR = mR / mX
            hR = hR.T

        ## Methodology proposed by Guilhoto
        # Idea: income = total consumption (usually < in TRUs and MIPs when working only with remunerations)
        else:
            ## Indicator for differentiation when saving spreadsheet
            sClosedGuilhotoIndicator = "_Closed_Guilhoto"
            print("Closed model: Guilhoto")

            ## Concatenating (vertically) final demand productive sectors and imports/taxes (without total lines)
            mFinalDemand_Import_Taxes = np.vstack((mFinalDemand, mSP_FD))

            ## Finding consumption and total income under Guilhoto
            mC_Guilhoto, mR_Guilhoto, mEOB_Guilhoto, nTotalConsumption = \
                Support.closed_model_guilhoto(mFinalDemand_Import_Taxes, mAddedValue, nSectors, nColISFLSFConsumption,
                                              nColFamilyConsumption, nRowRemunerations, nRowRM, nRowEOB)

            ## Calculating coefficients
            hC = mC_Guilhoto / nTotalConsumption
            hR = mR_Guilhoto / mX

            ## Replacing values in MIP (if requested)
            if bUpdateMIPClosedGuilhoto:
                # Replacing values in added value matrix
                mAddedValue_Guilhoto = mAddedValue.copy()
                mAddedValue_Guilhoto[nRowRemunerations, :] = mR_Guilhoto.reshape(-1)
                mAddedValue_Guilhoto[nRowRM, :] = 0
                mAddedValue_Guilhoto[nRowEOB, :] = mEOB_Guilhoto.reshape(-1)

                ## Creating new MIP DataFrame
                dfMIP_ClosedGuilhoto = dfMIP.copy()
                # Updating added value components
                dfMIP_ClosedGuilhoto.iloc[-15:-1, :nSectors] = mAddedValue_Guilhoto
                # Dropping EOB + RM and RM
                dfMIP_ClosedGuilhoto.drop(index=dfMIP.iloc[-8:-6, :].index.tolist(), inplace=True)

        ## A and Leontief's matrix in the closed model
        """
        In this case, Leontief's matrix shows, given a one unit increase in demand for products of sector j,
        what are the direct, indirect and induced prerequisites for each sector's production.
        Therefore, the coefficients of mB_closed are larger than those of mB and their difference can be interpreted
        as the induced impacts of household consumption expansion upon the production of each sector.
        """
        # Calculating A and Leontief's Matrices
        mA_closed, mB_closed = Support.leontief_closed(mA, hC, hR, nSectors)

        ### Supply-side model
        """
        In this model, we look at the economy by the supply side, which has a few implications:
        1. To calculate direct technical coefficients (mF matrix), we divide by production of sector i, not j.
        Therefore, mF tells us the percentage of sector's i production that was sold to activity j.
        2. Since we are using the supply-side coefficients, the exogenous variable is no longer final demand;
        we use the total payment sector vector (PS: imports, taxes and added value components).
        In other words, we have that X = PS*G, where G is the Ghosh Matrix = inv(I-F).
        """
        ## Calculating F and Ghosh's Matrices
        mF, mGhosh = Support.ghosh_supply(mZ, mX, nSectors)

        ### ============================================================================================
        ### Production Multipliers
        ### ============================================================================================

        ## Simple Production Multipliers (open model)
        """
        Given an increase of 1 in the demand of sector j, how much output/production is generated in the economy?
        Considers not only the direct effects, but also the indirect ones (power series approximation).
        """
        vMP = np.sum(mB, axis=0)

        ## Total Production Multipliers (closed model)
        """
        Given an increase of 1 in the demand of sector j, how much output/production is generated 
        in the economy including the induced effects of household consumption expansion?
        It can be decomposed into a series of different effects (see Vale, Perobelli, p.43):
            - Induced effect (mB_closed - mB)
            - Direct effect (mA)
            - Indirect effect (mB - mA)
        """
        vMPT = np.sum(mB_closed[:, :nSectors], axis=0)
        vInducedEffect = np.sum(mB_closed[:, :nSectors], axis=0) - np.sum(mB, axis=0)
        vDirectEffect = np.sum(mA, axis=0)
        vIndirectEffect = np.sum(mB, axis=0) - np.sum(mA, axis=0)

        ## Total Truncated Production Multipliers (closed model)
        """
        Given an increase of 1 in the demand of sector j, how much output is generated 
        in the economy, including the induced effects of household consumption expansion 
        (but only considering the productive sectors; in other words, not considering
        the direct impact of household consumption on GDP, but only its induced effects)?
        """
        vMPTT = np.sum(mB_closed[:nSectors, :nSectors], axis=0)
        vInducedEffectTrunc = np.sum(mB_closed[:nSectors, :nSectors], axis=0) - np.sum(mB, axis=0)

        ## Creating array with all multiplier names
        mProdMultipliers_Col_Names = [
            "Setor", "Multiplicador Simples de Produção", "Multiplicador Total de Produção",
            "Multiplicador Total de Produção Truncado", "Efeito Direto", "Efeito Indireto", "Efeito Induzido"
        ]
        ## Creating table with all multipliers
        mProdMultipliers = np.vstack((vSectors, vMP, vMPT, vMPTT, vDirectEffect, vIndirectEffect, vInducedEffect)).T

        ### ============================================================================================
        ### Labor Multipliers
        """
        In line with the production multipliers, the simple labor multipliers tell us how many jobs
        are generated (directly and indirectly) when there is a 1 million increase in demand for sector's j products
        The total truncated labor multipliers, in turn, includes the induced effects of consumption expansion
        Type I multipliers tell us how many jobs are directly and indirectly generated for each job directly created
        Type II multipliers tell us how many jobs are directly, indirectly and "inducedly" generated for each direct job
        """
        ### ============================================================================================

        ## Creating array with all multiplier names
        mEmpMultipliers_Col_Names = [
            "Setor", "Coeficiente", "Multiplicador Simples de Emprego", "Multiplicador de Emprego Tipo I",
            "Multiplicador Total de Emprego (truncado)", "Multiplicador de Emprego Tipo II",
            "Efeito Direto", "Efeito Indireto", "Efeito Induzido"
        ]
        ## Creating table with all multipliers
        mEmpMultipliers = Support.calc_multipliers(mE, mX, mA, mB, mB_closed, vSectors, nSectors)

        ### ============================================================================================
        ### Income Multipliers: Same interpretation as above, but without the 1 million unit denominator
        ### ============================================================================================

        ## Creating array with all multiplier names
        mIncomeMultipliers_Col_Names = [
            "Setor", "Coeficiente", "Multiplicador Simples de Renda do Trabalho",
            "Multiplicador de Renda do Trabalho Tipo I", "Multiplicador Total de Renda do Trabalho (truncado)",
            "Multiplicador de Renda do Trabalho Tipo II", "Efeito Direto", "Efeito Indireto", "Efeito Induzido"
        ]
        ## Creating table with all multipliers
        mIncomeMultipliers = Support.calc_multipliers(mR, mX, mA, mB, mB_closed, vSectors, nSectors)

        ### ============================================================================================
        ### Capital (EOB) Multipliers: Same interpretation as that of income multipliers
        ### ============================================================================================

        ## Defining mEOB vector (nSectors x 1 matrix)
        mEOB = mAddedValue[nRowEOB, :].reshape((nSectors, 1))

        ## Creating array with all multiplier names
        mEOBMultipliers_Col_Names = [
            "Setor", "Coeficiente", "Multiplicador Simples de Renda do Capital",
            "Multiplicador de Renda do Capital Tipo I", "Multiplicador Total de Renda do Capital (truncado)",
            "Multiplicador de Renda do Capital Tipo II", "Efeito Direto", "Efeito Indireto", "Efeito Induzido"
        ]
        ## Creating table with all multipliers
        mEOBMultipliers = Support.calc_multipliers(mEOB, mX, mA, mB, mB_closed, vSectors, nSectors)

        ### ============================================================================================
        ### Taxes Multipliers: Same interpretation as above and considering only sectorial taxes
        ### (not including any final demand components present in mSP_FD)
        ### ============================================================================================

        ## Creating array with all multiplier names
        mTaxesMultipliers_Col_Names = [
            "Setor", "Coeficiente", "Multiplicador Simples de Impostos", "Multiplicador de Impostos Tipo I",
            "Multiplicador Total de Impostos (truncado)", "Multiplicador de Impostos Tipo II",
            "Efeito Direto", "Efeito Indireto", "Efeito Induzido"
        ]

        ## "Vector" (nSectors x 1 matrix) containing all taxes paid by sectors (not considering mSP_FD)
        mTaxes = np.sum(mSP[1:5, :], axis=0, keepdims=True).T

        ## Creating table with all multipliers
        mTaxesMultipliers = Support.calc_multipliers(mTaxes, mX, mA, mB, mB_closed, vSectors, nSectors)

        ### ============================================================================================
        ### Energy Requirements
        ### ============================================================================================

        ## Defining energy vector (nSectors x 1 matrix)
        mEnergy = mZ[nRowEnergy, :].reshape((nSectors, 1))

        ## Creating array with all multiplier names
        mEnergyMultipliers_Col_Names = [
            "Setor", "Coeficiente", "Requerimentos Simples de Energia", "Requerimentos de Energia Tipo I",
            "Requerimentos Totais de Energia", "Requerimentos de Energia Tipo II", "Requerimentos Diretos",
            "Requerimentos Indiretos", "Requerimentos Induzidos"
        ]
        ## Creating table with all multipliers
        mEnergyMultipliers = Support.calc_multipliers(mEnergy, mX, mA, mB, mB_closed, vSectors, nSectors)

        ### ============================================================================================
        ### Linkages (Hirschman-Rasmussen - HR) and Variance Coefficients
        """
        The indices show which sectors have larger chaining impacts in the economic, not only buying from other
        sectors in order to meet rises in its final demand ("backwards"/dispersion power - 
        how much the sector demands from others), but also producing to meet rising final demand in the other 
        economic sectors ("forwards"/dispersion sensibility - how much the sector is demand by the others).
        We can normalize this impacts (dividing by the indicator's mean) in order to see which sectors
        are relatively more important/chained in the economy (norm. ind. > 1 -> bigger than the mean).
        """
        ### ============================================================================================

        ## Calculating forwards and backwards
        # Column names
        mIndLig_Col_Names = ["Setor", "Para Trás", "Para Frente", "Para Frente Ghosh"]

        # Calculations and appending "Setor-Chave" to names vector
        mIndLig = Support.linkages(mB, mGhosh, mIndLig_Col_Names, nSectors, vSectors)
        mIndLig_Col_Names.append("Setor-Chave")

        ### Variance Coefficients
        ## The lower the coefficient, the larger the number of sectors impacted by that sector's...
        # ... increase in production/sales
        CVi = np.std(mB, axis=1, ddof=1) / np.mean(mB, axis=1)
        # ... increase in final demand
        CVj = np.std(mB, axis=0, ddof=1) / np.mean(mB, axis=0)

        ## Joining into an aggregated table
        mVarCoef_Col_Names = ["Setor", "CVi", "CVj"]
        mVarCoef = np.vstack((vSectors, CVi, CVj)).T

        ### Pure Linkages (GHS or, in portuguese, IPL)
        """
        As pointed out by Guilhoto et al. (1994, 1996) and Guilhoto (2009), the traditional indexes don't take into
        consideration the production levels of each sector. The "pure" or "generalized" version doesn't have this problem.
        The backwards pure index (PBL) shows the impact of the production value of sector j upon the rest of the economy,
        excluding self-demand for its own inputs and the returns of the rest of the economy to the sector, representing,
        therefore, the relative importance of that sector's DEMAND.
        The forward index (PFL) indicates the impact of the production value of the rest of the economy upon the
        production of sector j, representing, therefore, the relative importance of that sector's SUPPLY.
        """

        ## Calculating IPL
        mIndPureLig_Col_Names = ["Setor", "PBL", "PFL", "PTL"]
        mIndPureLig, mIndPureLigNorm = Support.calc_ipl(mY, mA, vSectors, nSectors)

        ## Checking key sectors
        # Transforming into a dataframe
        dfIndPureLigNorm = pd.DataFrame(mIndPureLigNorm, columns=mIndPureLig_Col_Names)
        dfIndPureLigNorm['Setores-Chave'] = np.where(dfIndPureLigNorm['PTL'] >= 1, "Setor-Chave", "-")

        # Updating array
        mIndPureLig_Col_Names = ["Setor", "PBL", "PFL", "PTL", "Setor-Chave"]
        mIndPureLigNorm = dfIndPureLigNorm.to_numpy()

        ### ======================================================================================
        ### Influence Matrices
        """
        For more information, see Vale, Perobelli, 2020, p.98
        Although the indexes above show the importance of each sector in the economy as whole, it is difficult
        to visualize the main links through which this happens. Therefore, this concept shows how the changes
        in the direct technical coefficients are distributed throughout the economy, allowing us to see
        which relations among sectors are the most important within the productive sectors.
        In order to capture these individual changes, we use a singular increment matrix (with one element
        corresponding to the increment an the others, 0) an add that to the A matrix, calculating a new
        Leontief matrix. The influence of that sector's relation can be found subtracting the new Leontief
        by the default one and dividing by the increment
        """
        ### ============================================================================================

        ## Setting increment
        nIncrement = 0.001

        ### Influence Matrix (see Vale, Perobelli, p. 98-103)
        mInfluence = Support.influence_matrix(mA, nIncrement, nSectors)

        ### ============================================================================================
        ### Hypothetical Extraction
        """
        What would happen if we extract a sector from economy? What if it doesn't buy anything from any other
        sectors or doesn't produce inputs from other sectors?
        This technique allows us to analyze the importance of the sector by eliminating it from the economy
        and measuring how much economic production decreases: the larger the interdependency of that sector
        within the economy, the larger the production loss.
        """
        ### ============================================================================================

        mExtractions_Col_Names = ["Setor", "BL", "FL", "BL%", "FL%"]
        mExtractions = Support.extraction(mA, mF, mX, mY, mSP, vSectors, nSectors)

        ### ============================================================================================
        ### Exporting table to Excel
        ### ============================================================================================

        if bWriteExcel:
            print(f"Writing Excel file... ({datetime.datetime.now()})")

            # Original Input-Output Matrix
            vNameSheets = ["MIP_Original"]
            vDataSheets = [dfMIP]

            # Guilhoto's Open Model Matrix (if requested)
            if bClosedGuilhoto and bUpdateMIPClosedGuilhoto:
                vNameSheets.append("MIP_ClosedGuilhoto")
                vDataSheets.append(dfMIP_ClosedGuilhoto)

            # Production Multipliers
            vNameSheets.append("Mult_Prod")
            vDataSheets.append(
                pd.DataFrame(mProdMultipliers[:, 1:], columns=mProdMultipliers_Col_Names[1:], index=vSectors)
            )

            # Employment/Labor Multipliers
            vNameSheets.append("Mult_Trab")
            vDataSheets.append(
                pd.DataFrame(mEmpMultipliers[:, 1:], columns=mEmpMultipliers_Col_Names[1:], index=vSectors))

            # Work Income Multipliers
            vNameSheets.append("Mult_Remuneracoes")
            vDataSheets.append(
                pd.DataFrame(mIncomeMultipliers[:, 1:], columns=mIncomeMultipliers_Col_Names[1:], index=vSectors)
            )

            # Capital Income Multipliers
            vNameSheets.append("Mult_Capital")
            vDataSheets.append(
                pd.DataFrame(mEOBMultipliers[:, 1:], columns=mEOBMultipliers_Col_Names[1:], index=vSectors)
            )

            # Taxes Multipliers
            vNameSheets.append("Mult_Imp")
            vDataSheets.append(
                pd.DataFrame(mTaxesMultipliers[:, 1:], columns=mTaxesMultipliers_Col_Names[1:], index=vSectors)
            )

            # Energy requirements
            vNameSheets.append("Req_Energia")
            vDataSheets.append(
                pd.DataFrame(mEnergyMultipliers[:, 1:], columns=mEnergyMultipliers_Col_Names[1:], index=vSectors)
            )

            # Variance Coefficients
            vNameSheets.append("Coef_Var")
            vDataSheets.append(pd.DataFrame(mVarCoef[:, 1:], columns=mVarCoef_Col_Names[1:], index=vSectors))

            # "Índices de Ligação" (HR Indices)
            vNameSheets.append("Ind_Lig")
            vDataSheets.append(pd.DataFrame(mIndLig[:, 1:], columns=mIndLig_Col_Names[1:], index=vSectors))

            # "Índices de Ligação Puros Normalizados" (GHS Indices)
            vNameSheets.append("Ind_Lig_Puros")
            vDataSheets.append(pd.DataFrame(mIndPureLigNorm[:, 1:], columns=mIndPureLig_Col_Names[1:], index=vSectors))

            # Influence Areas
            vNameSheets.append("Campo_Influencia")
            vDataSheets.append(pd.DataFrame(mInfluence, columns=vSectors, index=vSectors))

            # Hypothetical Extractions
            vNameSheets.append("Extr_Hip")
            vDataSheets.append(pd.DataFrame(mExtractions[:, 1:], columns=mExtractions_Col_Names[1:], index=vSectors))

            # Direct coefficients (open model)
            vNameSheets.append("Coef_Diretos_Aberto (mA)")
            vDataSheets.append(pd.DataFrame(mA, columns=vSectors, index=vSectors))

            # Leontief (open model)
            vNameSheets.append("Leontief Aberto (mB)")
            vDataSheets.append(pd.DataFrame(mB, columns=vSectors, index=vSectors))

            ## Direct coefficients (closed model)
            # Appending necessary things to indexes/columns
            colClosed = np.append(vSectors, "Consumo das Famílias")
            indexClosed = np.append(vSectors, "Remunerações")

            # Creating dataframe
            vNameSheets.append("Coef_Diretos_Fechado (mA)")
            vDataSheets.append(pd.DataFrame(mA_closed, columns=colClosed, index=indexClosed))

            # Leontief (closed model)
            vNameSheets.append("Leontief Fechado (mB)")
            vDataSheets.append(pd.DataFrame(mB_closed, columns=colClosed, index=indexClosed))

            # Direct coefficients (supply-side model)
            vNameSheets.append("Coef_Diretos_Oferta (mA)")
            vDataSheets.append(pd.DataFrame(mF, columns=vSectors, index=vSectors))

            # Leontief (supply-side model)
            vNameSheets.append("Matriz de Ghosh")
            vDataSheets.append(pd.DataFrame(mGhosh, columns=vSectors, index=vSectors))

            ## Writing Excel File to 'Output' directory
            Support.write_data_excel(sDirectory="./Output/Tabelas_Main/Análises/",
                                     sFileName=f"Resultados_{nYear}_{nSectors}{sAPF}{sClosedGuilhotoIndicator}.xlsx",
                                     vSheetName=vNameSheets, vDataSheet=vDataSheets)

        ### ============================================================================================

        ## Ending everything
        if nYear == nYear0:
            mMultProdSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                            columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultProdTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                        columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultProdTotTrunc = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                             columns=[f"{i}" for i in range(nYear0, nYear1)])
            mProdDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                    columns=[f"{i}" for i in range(nYear0, nYear1)])
            mProdIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                      columns=[f"{i}" for i in range(nYear0, nYear1)])
            mProdInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                      columns=[f"{i}" for i in range(nYear0, nYear1)])

            mMultEmpregoSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                               columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultEmpregoTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                           columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultEmpregoT1 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultEmpregoT2 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEmpDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                   columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEmpIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                     columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEmpInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                     columns=[f"{i}" for i in range(nYear0, nYear1)])

            mMultRemunSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                             columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultRemunTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultRemunT1 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                        columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultRemunT2 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                        columns=[f"{i}" for i in range(nYear0, nYear1)])
            mRemunDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                     columns=[f"{i}" for i in range(nYear0, nYear1)])
            mRemunIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                       columns=[f"{i}" for i in range(nYear0, nYear1)])
            mRemunInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                       columns=[f"{i}" for i in range(nYear0, nYear1)])

            mMultCapitalSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                               columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultCapitalTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                           columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultCapitalT1 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultCapitalT2 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])
            mCapitalDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                       columns=[f"{i}" for i in range(nYear0, nYear1)])
            mCapitalIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])
            mCapitalInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])

            mMultImpostosSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                                columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultImpostosTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                            columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultImpostosT1 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                           columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultImpostosT2 = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                           columns=[f"{i}" for i in range(nYear0, nYear1)])
            mImpostosDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                        columns=[f"{i}" for i in range(nYear0, nYear1)])
            mImpostosIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])
            mImpostosInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                          columns=[f"{i}" for i in range(nYear0, nYear1)])

            mMultEnergiaSimples = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                               columns=[f"{i}" for i in range(nYear0, nYear1)])
            mMultEnergiaTot = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                           columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEnergiaDir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                       columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEnergiaIndir = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])
            mEnergiaInduz = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])

            mIndLigTras = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                       columns=[f"{i}" for i in range(nYear0, nYear1)])
            mIndLigFrente = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                         columns=[f"{i}" for i in range(nYear0, nYear1)])
            mIndLigFrenteGhosh = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors,
                                              columns=[f"{i}" for i in range(nYear0, nYear1)])

            mPBL = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors, columns=[f"{i}" for i in range(nYear0, nYear1)])
            mPFL = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors, columns=[f"{i}" for i in range(nYear0, nYear1)])
            mPTL = pd.DataFrame(np.zeros([nSectors, 10]), index=vSectors, columns=[f"{i}" for i in range(nYear0, nYear1)])

        mMultProdSimples.values[:, nYear - nYear0] = mProdMultipliers[:, 1]
        mMultProdTot.values[:, nYear - nYear0] = mProdMultipliers[:, 2]
        mMultProdTotTrunc.values[:, nYear - nYear0] = mProdMultipliers[:, 3]
        mProdDir.values[:, nYear - nYear0] = mProdMultipliers[:, 4]
        mProdIndir.values[:, nYear - nYear0] = mProdMultipliers[:, 5]
        mProdInduz.values[:, nYear - nYear0] = mProdMultipliers[:, 6]

        mMultEmpregoSimples.values[:, nYear - nYear0] = mEmpMultipliers[:, 2]
        mMultEmpregoTot.values[:, nYear - nYear0] = mEmpMultipliers[:, 4]
        mMultEmpregoT1.values[:, nYear - nYear0] = mEmpMultipliers[:, 3]
        mMultEmpregoT2.values[:, nYear - nYear0] = mEmpMultipliers[:, 5]
        mEmpDir.values[:, nYear - nYear0] = mEmpMultipliers[:, 6]
        mEmpIndir.values[:, nYear - nYear0] = mEmpMultipliers[:, 7]
        mEmpInduz.values[:, nYear - nYear0] = mEmpMultipliers[:, 8]

        mMultRemunSimples.values[:, nYear - nYear0] = mIncomeMultipliers[:, 2]
        mMultRemunTot.values[:, nYear - nYear0] = mIncomeMultipliers[:, 4]
        mMultRemunT1.values[:, nYear - nYear0] = mIncomeMultipliers[:, 3]
        mMultRemunT2.values[:, nYear - nYear0] = mIncomeMultipliers[:, 5]
        mRemunDir.values[:, nYear - nYear0] = mIncomeMultipliers[:, 6]
        mRemunIndir.values[:, nYear - nYear0] = mIncomeMultipliers[:, 7]
        mRemunInduz.values[:, nYear - nYear0] = mIncomeMultipliers[:, 8]

        mMultCapitalSimples.values[:, nYear - nYear0] = mEOBMultipliers[:, 2]
        mMultCapitalTot.values[:, nYear - nYear0] = mEOBMultipliers[:, 4]
        mMultCapitalT1.values[:, nYear - nYear0] = mEOBMultipliers[:, 3]
        mMultCapitalT2.values[:, nYear - nYear0] = mEOBMultipliers[:, 5]
        mCapitalDir.values[:, nYear - nYear0] = mEOBMultipliers[:, 6]
        mCapitalIndir.values[:, nYear - nYear0] = mEOBMultipliers[:, 7]
        mCapitalInduz.values[:, nYear - nYear0] = mEOBMultipliers[:, 8]

        mMultImpostosSimples.values[:, nYear - nYear0] = mTaxesMultipliers[:, 2]
        mMultImpostosTot.values[:, nYear - nYear0] = mTaxesMultipliers[:, 4]
        mMultImpostosT1.values[:, nYear - nYear0] = mTaxesMultipliers[:, 3]
        mMultImpostosT2.values[:, nYear - nYear0] = mTaxesMultipliers[:, 5]
        mImpostosDir.values[:, nYear - nYear0] = mTaxesMultipliers[:, 6]
        mImpostosIndir.values[:, nYear - nYear0] = mTaxesMultipliers[:, 7]
        mImpostosInduz.values[:, nYear - nYear0] = mTaxesMultipliers[:, 8]

        mMultEnergiaSimples.values[:, nYear - nYear0] = mEnergyMultipliers[:, 2]
        mMultEnergiaTot.values[:, nYear - nYear0] = mEnergyMultipliers[:, 4]
        mEnergiaDir.values[:, nYear - nYear0] = mEnergyMultipliers[:, 6]
        mEnergiaIndir.values[:, nYear - nYear0] = mEnergyMultipliers[:, 7]
        mEnergiaInduz.values[:, nYear - nYear0] = mEnergyMultipliers[:, 8]

        mIndLigTras.values[:, nYear - nYear0] = mIndLig[:, 1]
        mIndLigFrente.values[:, nYear - nYear0] = mIndLig[:, 2]
        mIndLigFrenteGhosh.values[:, nYear - nYear0] = mIndLig[:, 3]

        mPBL.values[:, nYear - nYear0] = mIndPureLigNorm[:, 1]
        mPFL.values[:, nYear - nYear0] = mIndPureLigNorm[:, 2]
        mPTL.values[:, nYear - nYear0] = mIndPureLigNorm[:, 3]

    vNomes = ["Mult Produção Simples", "Mult Produção Total", "Mult Produção Total Truncado",
              "Mult Emprego Simples", "Mult Emprego Total",
              "Mult Remunerações Simples", "Mult Remunerações Total",
              "Mult EOB Simples", "Mult EOB Total",
              "Mult Impostos Simples", "Mult Impostos Total",
              "Índice Trás", "Índice Frente", "Índice FrenteGhosh",
              "PBL", "PFL", "PTL",
              "Req Energia Simples", "Req Energia Total",
              "Mult Emprego T1", "Mult Emprego T2", "Mult Remunerações T1", "Mult Remunerações T2",
              "Mult EOB T1", "Mult EOB T2", "Mult Impostos T1", "Mult Impostos T2",
              "Direto Emprego", "Indireto Emprego", "Induzido Emprego",
              "Direto Remunerações", "Indireto Remunerações", "Induzido Remunerações",
              "Direto EOB", "Indireto EOB", "Induzido EOB",
              "Direto Impostos", "Indireto Impostos", "Induzido Impostos",
              "Direto Energia", "Indireto Energia", "Induzido Energia"]

    vDados = [mMultProdSimples, mMultProdTot, mMultProdTotTrunc, mMultEmpregoSimples, mMultEmpregoTot,
              mMultRemunSimples, mMultRemunTot, mMultCapitalSimples, mMultCapitalTot,
              mMultImpostosSimples, mMultImpostosTot, mIndLigTras, mIndLigFrente, mIndLigFrenteGhosh,
              mPBL, mPFL, mPTL, mMultEnergiaSimples, mMultEnergiaTot,
              mMultEmpregoT1, mMultEmpregoT2, mMultRemunT1, mMultRemunT2,
              mMultCapitalT1, mMultCapitalT2, mMultImpostosT1, mMultImpostosT2,
              mEmpDir, mEmpIndir, mEmpInduz, mRemunDir, mRemunIndir, mRemunInduz,
              mCapitalDir, mCapitalIndir, mCapitalInduz, mImpostosDir, mImpostosIndir, mImpostosInduz,
              mEnergiaDir, mEnergiaIndir, mEnergiaInduz]

    Support.write_data_excel(sDirectory="./Output/Tabelas_Main/",
                             sFileName=f"Compilados_{nSectors}_{nYear0}_{nYear1 - 1}{sClosedGuilhotoIndicator}.xlsx",
                             vSheetName=vNomes, vDataSheet=vDados)

    time_diff = datetime.datetime.now() - sTimeBegin
    print(f"All done! ({datetime.datetime.now()})")
    print(f"{time_diff.seconds} seconds passed.")
