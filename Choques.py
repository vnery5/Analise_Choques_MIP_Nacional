"""
Impact analysis based on estimated matrices by EstimaMIP_Nacional (every version).
Important: sheet formatting has to be the SAME as those generated by EstimaMIP (including "Difference" line at the end)
Authors: João Maria de Oliveira and Vinícius de Almeida Nery Ferreira (Ipea-DF).
E-mails: joao.oliveira@ipea.gov.br and vinicius.nery@ipea.gov.br (or vnery5@gmail.com).
"""

## Importing necessary packages
import numpy as np
import pandas as pd
import datetime
import SupportFunctions as Support

## Only run if it's the main file (don't run on import)
if __name__ == '__main__':
    ## Matrix dimension
    # 1: 12 sectors
    # 2: 20 sectors
    # 3: 68 sectors
    # 9: more than 68 sectors
    # 0: other (specify number of sectors below)
    nDimension = 0

    ## Year to be analyzed
    nYear = 2018

    ## Use MIPs estimated under Guilhoto (2010) or Alves-Passoni, Freitas (APF) (2020)?
    bGuilhoto = True  # True or False

    ## Defining kind of shock
    # Demand Shock
    shockDemand = True  # True or False
    # Supply Shock (can be both!)
    shockSupply = False  # True or False
    # Absolute or relative (in % terms)
    shockAbsolute = False  # True or False

    ## Defining shock file parameters (remember that they have to have the same number of sectors as the estimated MIP)
    sFileShock = "Choque.xlsx"
    sSheetDemandShock = "Demanda"
    sSheetSupplyShock = "Oferta"

    ### Aggregate results?
    ## Remember that a sheet with the same number of sectors as the estimated mip has to be selected!
    Aggreg = False  # True or False
    sAggregFileName = "SetoresGrupo.xlsx"
    sAggregSheet = "SetorGrupo"

    ## If affirmative, how many base sector's would you like to aggregate to?
    nSectorsAggreg = 20  # 4, 12, 20

    ## Which sectors shall NOT be aggregated?
    # Use their index/number/position! (start: 0)
    # If you wish to get only the default 4/12/20, use None
    lDisaggreg_Sectors = None  # list of integers or None
    # lDisaggreg_Sectors = [61, 62, 63, 64, 65, 66]  # list of integers or None

    ### Add up/bundle sectors?
    Add_Sectors = False  # True or False

    ## Which sectors shall be bundled up together?
    # Use their index/number/position! (start: 0)
    lAdd_Sectors = [61, 62, 64, 65]  # list of integers
    # What shall them be named? Put the name for each index (both lists have to be the same size)
    lAdd_Names = ["Educação Básica"] * 4

    ### ============================================================================================

    ### Defining file paths and names
    if nDimension == 0:
        nSectorsFile = 67  # How many sectors?
        invalidSectorNumber = ""
    elif nDimension == 9:
        nSectorsFile = "68+"
        invalidSectorNumber = ""
    elif nDimension == 0:
        nSectorsFile = 4
        invalidSectorNumber = ""
    else:
        ## Dimensions -> sectors list
        listDimensions = [12, 20, 68]
        try:
            nSectorsFile = listDimensions[nDimension - 1]
            invalidSectorNumber = ""
        except IndexError:
            nSectorsFile = listDimensions[2]
            invalidSectorNumber = "Couldn't find desired dimension. Running for 68 sectors."
            nDimension = 3

    ## Estimated MIPs files
    # Sheet formatting has to be the SAME as those generated by EstimaMIP (including a "difference" line at the end)
    sPathMIP = "./Input/MIPs Estimadas/"
    sAPF = "" if bGuilhoto else "_Patieene"
    sFileNameMIP = f"MIP_{nYear}_{nSectorsFile}{sAPF}.xlsx"

    # Joining path and file name
    sFileMIP = sPathMIP + sFileNameMIP
    # Sheet name
    sSheetNameMIP = "MIP"

    ## Shock file
    sPathInput = "./Input/"
    sFileShock = f"{sPathInput}{sFileShock}"

    ## Aggregation file
    sPathInput = "./Input/"
    sAggregFile = sPathInput + sAggregFileName

    ## Defining Indicators
    # Shock
    AbsIndicator = "_Abs" if shockAbsolute else "_Rel"
    DemandIndicator = "_Demand" if shockDemand else ""
    SupplyIndicator = "_Supply" if shockSupply else ""

    # Aggregation
    if Aggreg and Add_Sectors:
        AggregIndicator = "_Agg_Add"
    elif Aggreg:
        AggregIndicator = "_Agg"
    elif Add_Sectors:
        AggregIndicator = "_Add"
    else:
        AggregIndicator = ""

    ### ============================================================================================

    ### Print start
    sTimeBegin = datetime.datetime.now()
    print("======================= INPUT OUTPUT SHOCKS - VERSION 2 =======================")
    print(f"Starting for year = {nYear} and dimension = {nDimension} ({sTimeBegin})")
    print(f"Demand Shock = {shockDemand}; Supply Shock = {shockSupply}; Absolute = {shockAbsolute}")
    print(invalidSectorNumber)

    ## Read necessary matrices and get number of sectors and sector's names
    dfMIP, nSectors, vSectors, mZ, mY, vX, mC, vV, mR, mE, mSP, vAVNames, mAddedValue, vFDNames, mFinalDemand = \
        Support.read_estimated_mip(sFileMIP, sSheetName=sSheetNameMIP)

    # Getting payment sector of the final demand components
    mSP_FD = dfMIP.values[nSectors + 1:nSectors + 6, nSectors + 1:-2]

    ### ============================================================================================
    ### Calculating Shocks
    ### ============================================================================================
    """
    Using income, employment and added value coefficients, we will calculate the impact 
    of a given shock (supply or demand (or both)) on all of the added value components.
    """

    #### Loading shock matrices/vectors
    ### Reading with pandas, transforming into numpy and taking only the values
    ## Supply shock
    dfShockSupply = pd.read_excel(sFileShock, sheet_name=sSheetSupplyShock, index_col=[0, 1])
    mShockSupply = dfShockSupply.to_numpy()
    vShockSupply = mShockSupply[:, 0].astype(float)

    ## Demand Shock
    dfShockDemand = pd.read_excel(sFileShock, sheet_name=sSheetDemandShock, index_col=[0, 1])
    mShockDemand = dfShockDemand.to_numpy().astype(float)

    # Adjusting if the shock is relative
    if not shockAbsolute:
        dfShockDemand += 1
        dfShockSupply += 1
        mShockDemand += 1
        mShockSupply += 1
        vShockSupply += 1

    # Ignoring division by zero (they are handled after)
    np.seterr(divide='ignore', invalid='ignore')

    #### Values that will be used for both shocks
    ### DEMAND
    ## Adjusting new final demand according to whether the shock is relative or not
    mNewFD = mFinalDemand + mShockDemand if shockAbsolute else mFinalDemand * mShockDemand
    # Adding up to find new final demand and shaping it as a matrix
    mNewY = np.sum(mNewFD, axis=1)
    mNewY = np.reshape(mNewY, (nSectors, 1))

    ### SUPPLY
    ## Calculating new employment
    mNewE = mE + mShockSupply if shockAbsolute else mE * mShockSupply

    ## Assuming that the labor restrictions apply to intersectorial relations, we multiply/add
    # the intermediate consumption that each sectors consumes by the restriction vector
    mNewZ = mZ + vShockSupply[None, :] if shockAbsolute else mZ * vShockSupply[None, :]

    ## Reshaping to vectors
    vX = np.reshape(vX, -1)
    mNewE = np.reshape(mNewE, - 1)
    mY = np.reshape(mY, - 1)  # transforming into a vector
    mNewY = np.reshape(mNewY, - 1)
    vV = np.reshape(vV, -1)

    ## Calculating coefficients
    # Dividing each added value component by the total production of that sector and converting to float
    mCoefAV = (mAddedValue / vX[None, :]).astype(float)
    # Doing the same for the payment sector (imports, taxes)
    mCoefSP = (mSP / vX[None, :]).astype(float)

    ## Calculating Leontief Matrix (open model)
    mA, mB = Support.leontief_open(mZ, vX, nSectors)

    ## Adjusting final demand of the payment sector components
    # Getting total national base-prices percentage changes for each demand component
    vFD_Change = np.sum(mNewFD, axis=0) / np.sum(mFinalDemand, axis=0)

    # Applying same percentage change to the payment sector components
    mNewSP_FD = mSP_FD * vFD_Change[None, :]

    ########################### DEMAND SHOCK ###########################
    if shockDemand:
        ## Finding new production vector
        vNewX = np.dot(mB, mNewY)
        vNewX = np.reshape(vNewX, - 1).astype(float)  # transforming into a vector

        ## Multiplying by the coefficients to get new added value and payment sector
        mNewAddedValue = mCoefAV * vNewX[None:, ]
        mNewSP = mCoefSP * vNewX[None:, ]

        ## Calculating deltas
        # Absolute
        deltaX = vNewX - vX
        deltaAV = mNewAddedValue - mAddedValue
        deltaSP = mNewSP - mSP

        # Relative
        percentageX = deltaX / vX
        percentageAV = deltaAV / mAddedValue
        percentageAV = np.where((np.isinf(percentageAV)) | (np.isnan(percentageAV)), 0, percentageAV)
        percentageSP = deltaSP / mSP
        percentageSP = np.where((np.isinf(percentageSP)) | (np.isnan(percentageSP)), 0, percentageSP)

    ########################### SUPPLY SHOCK ###########################
    if shockSupply:
        # If there is also a demand shock, use that final demand vector
        mY = mNewY if shockDemand else mY

        ## Calculating new employment coefficients
        hNewE = mNewE / vX

        # # Substituting in the added value matrix
        # mNewCoefAV = np.copy(mCoefAV)
        # mNewCoefAV[-1, :] = hNewE

        # Calculating new direct and indirect coefficients
        mNewA, mNewB = Support.leontief_open(mNewZ, vX, nSectors)

        # Calculating new production
        vNewX = np.dot(mNewB, mY)

        ## Multiplying by the coefficients to get new added value and payment sector
        mNewAddedValue = mCoefAV * vNewX[None:, ]
        mNewSP = mCoefSP * vNewX[None:, ]

        ## Calculating deltas
        # Absolute
        deltaX = vNewX - vX
        deltaAV = mNewAddedValue - mAddedValue
        deltaSP = mNewSP - mSP

        # Relative
        percentageX = deltaX / vX
        percentageAV = deltaAV / mAddedValue
        percentageAV = np.where((np.isinf(percentageAV)) | (np.isnan(percentageAV)), 0, percentageAV)

        percentageSP = deltaSP / mSP
        percentageSP = np.where((np.isinf(percentageSP)) | (np.isnan(percentageSP)), 0, percentageSP)

    ### ============================================================================================
    ### Creating DataFrames and exporting to Excel
    ### ============================================================================================

    ### Adjusting table formats
    ## Pivotting added value and payment sector tables (in order for the sectors to be in the rows)
    # Added Value
    mCoefAV = mCoefAV.T
    mAddedValue = mAddedValue.T
    mNewAddedValue = mNewAddedValue.T
    deltaAV = deltaAV.T
    percentageAV = percentageAV.T

    # Payment sector
    mCoefSP = mCoefSP.T
    mSP = mSP.T
    mNewSP = mNewSP.T
    deltaSP = deltaSP.T
    percentageSP = percentageSP.T

    ## Creating total added value ("GDP") vectors
    # Not really GDP, as we don't have taxes for intermediate consumption and final demand
    vV = vV
    vNewV = mNewAddedValue[:, 0]
    deltaV = deltaAV[:, 0]
    percentageV = deltaV / vV
    percentageV = np.where((np.isinf(percentageV)) | (np.isnan(percentageV)), 0, percentageV)

    ### Total added value (GDP) and production stats
    ## Column Names
    mSheetV_ColNames = ["Novo VA Setorial", "VA Setorial", "Impacto Absoluto", "Impacto Relativo (%)"]
    mSheetX_ColNames = ["Nova Produção (VPB)", "Produção (VPB)", "Impacto Absoluto", "Impacto Relativo (%)"]

    ## Values
    # 'GDP' (Sectoral Added Value)
    dfSheetV = Support.format_shock_sheet(vNewV, vV, deltaV, percentageV, vSectors, mSheetV_ColNames)

    # Production
    dfSheetX = Support.format_shock_sheet(vNewX, vX, deltaX, percentageX, vSectors, mSheetX_ColNames)

    ## Getting total impacts (added across sectors) for a series of statistics
    vImpactSheet_Index = ["VPB", "VA Setorial", "Impostos s/Produtos (CI)", "Impostos s/Produtos (DF)",
                          "PIB", "Empregos", "EOB", "RM", "EOB+RM", "Remunerações", "Outros Impostos"]
    vImpactSheet_Cols = ["Novo", "Antigo", "Impacto Absoluto", "Impacto Relativo"]

    # Total Production
    vProduction = Support.calculate_total_impact(vNewX, vX, deltaX)

    # Sectorial Added Value
    vAV_Sectors = Support.calculate_total_impact(vNewV, vV, deltaV)

    # Taxes
    vTaxesProductsIC = Support.calculate_total_impact(mNewSP[:, 1:-1], mSP[:, 1:-1], deltaSP[:, 1:-1])
    vTaxesProductsFD = Support.calculate_total_impact(mNewSP_FD[1:, :], mSP_FD[1:, :], mNewSP_FD[1:, :] - mSP_FD[1:, :])
    vOtherTaxesProd = Support.calculate_total_impact(mNewAddedValue[:, -4:-2], mAddedValue[:, -4:-2], deltaAV[:, -4:-2])
    vTaxes = vTaxesProductsIC + vOtherTaxesProd + vTaxesProductsFD

    # GDP
    vGDP = vAV_Sectors + vTaxes - vOtherTaxesProd

    # Employment
    vEmp = Support.calculate_total_impact(mNewAddedValue[:, -1], mAddedValue[:, -1], deltaAV[:, -1])

    # EOB (capital income)
    vEOB = Support.calculate_total_impact(mNewAddedValue[:, -5], mAddedValue[:, -5], deltaAV[:, -5])

    # Mixed Incomes (in portuguese, RM)
    vRM = Support.calculate_total_impact(mNewAddedValue[:, -6], mAddedValue[:, -6], deltaAV[:, -6])

    # EOB + RM
    vEOB_RM = Support.calculate_total_impact(mNewAddedValue[:, -7], mAddedValue[:, -7], deltaAV[:, -7])

    # Remunerations
    vRem = Support.calculate_total_impact(mNewAddedValue[:, 1], mAddedValue[:, 1], deltaAV[:, 1])

    # Salaries
    vSal = Support.calculate_total_impact(mNewAddedValue[:, 2], mAddedValue[:, 2], deltaAV[:, 2])

    ## Joining all vectors vertically
    mImpactSheet = np.vstack((vProduction, vAV_Sectors, vTaxesProductsIC, vTaxesProductsFD,
                              vGDP, vEmp, vEOB, vRM, vEOB_RM, vRem, vOtherTaxesProd))

    # Formatting percentage change column
    mImpactSheet = mImpactSheet.astype('object')
    mImpactSheet[:, 3] = mImpactSheet[:, 2] / mImpactSheet[:, 1]
    mImpactSheet[:, 3] = [f"{round(100 * i, 3)}%" for i in mImpactSheet[:, 3]]
    mImpactSheet[:, 3] = [f"{i.replace('.', ',')}" for i in mImpactSheet[:, 3]]

    ## Creating DataFrame
    dfImpactSheet = pd.DataFrame(mImpactSheet, columns=vImpactSheet_Cols, index=vImpactSheet_Index)

    ### Added Value and Payment Sectors Coefficients and Individual Impacts
    ## Concatenating
    mCoef_SP_AV = np.concatenate((mCoefSP[:, :-1], mCoefAV), axis=1)
    mOld_SP_AV = np.concatenate((mSP[:, :-1], mAddedValue), axis=1)
    mNew_SP_AV = np.concatenate((mNewSP[:, :-1], mNewAddedValue), axis=1)
    mDelta_SP_AV = np.concatenate((deltaSP[:, :-1], deltaAV), axis=1)
    mPercentage_SP_AV = np.concatenate((percentageSP[:, :-1], percentageAV), axis=1)

    # Formatting percentage matrix
    mPercentage_SP_AV = mPercentage_SP_AV.astype('object')
    for r in range(mPercentage_SP_AV.shape[0]):
        for c in range(mPercentage_SP_AV.shape[1]):
            mPercentage_SP_AV[r, c] = f"{round(100 * mPercentage_SP_AV[r, c], 3)}%"
            mPercentage_SP_AV[r, c] = f"{mPercentage_SP_AV[r, c].replace('.', ',')}"

    ## Creating dataframes
    vSP_AV_Cols = np.append(["Importação", "Impostos de Importação", "IPI", "ICMS", "Outros Impostos"], vAVNames)

    dfCoef_SP_AV = pd.DataFrame(mCoef_SP_AV, index=vSectors, columns=vSP_AV_Cols)
    dfOld_SP_AV = pd.DataFrame(mOld_SP_AV, index=vSectors, columns=vSP_AV_Cols)
    dfNew_SP_AV = pd.DataFrame(mNew_SP_AV, index=vSectors, columns=vSP_AV_Cols)
    dfDelta_SP_AV = pd.DataFrame(mDelta_SP_AV, index=vSectors, columns=vSP_AV_Cols)
    dfPercentage_SP_AV = pd.DataFrame(mPercentage_SP_AV, index=vSectors, columns=vSP_AV_Cols)

    ### Aggregating/bundling results (if requested)
    if Aggreg or Add_Sectors:
        dfSheetV = Support.aggregate_shocks(dfSheetV, Aggreg=Aggreg, Add_Sectors=Add_Sectors,
                                            nSectorsAggreg=nSectorsAggreg,
                                            sAggregFile=sAggregFile, sAggregSheet=sAggregSheet,
                                            lAdd_Sectors=lAdd_Sectors, lDisaggreg_Sectors=lDisaggreg_Sectors,
                                            lAdd_Names=lAdd_Names, vSectors=vSectors)
        dfSheetX = Support.aggregate_shocks(dfSheetX, Aggreg=Aggreg, Add_Sectors=Add_Sectors,
                                            nSectorsAggreg=nSectorsAggreg,
                                            sAggregFile=sAggregFile, sAggregSheet=sAggregSheet,
                                            lAdd_Sectors=lAdd_Sectors, lDisaggreg_Sectors=lDisaggreg_Sectors,
                                            lAdd_Names=lAdd_Names, vSectors=vSectors)

    ### Generating Excel Table
    vNameSheets = ["MIP", "Choque_Demanda", "Choque_Oferta", f"Impacto 'PIB' (VA Setorial){AggregIndicator}",
                   f"Impacto VPB{AggregIndicator}", "Resumo Impactos",
                   "Coeficientes VA e SP", "Componentes VA - MIP", "Componentes VA - Choque", "Delta Componentes VA"]
    vDataSheets = [dfMIP, dfShockDemand, dfShockSupply, dfSheetV, dfSheetX, dfImpactSheet,
                   dfCoef_SP_AV, dfOld_SP_AV, dfNew_SP_AV, dfDelta_SP_AV]

    ## Writing Excel File to 'Output' directory
    # File Name
    sFileS = f"Choque_{nYear}_{nSectors}{sAPF}{AbsIndicator}{DemandIndicator}{SupplyIndicator}{AggregIndicator}.xlsx"
    Support.write_data_excel(sDirectory="./Output/Tabelas_Main/Choques e Coeficientes/",
                             sFileName=sFileS,
                             vSheetName=vNameSheets, vDataSheet=vDataSheets)

    ### ============================================================================================

    ## Ending everything
    time_diff = datetime.datetime.now() - sTimeBegin
    print(f"All done! ({datetime.datetime.now()})")
    print(f"{time_diff.seconds} seconds passed.")
